# using DFTK
using ProgressMeter
using LinearAlgebra


########################################################
#                                                      #
##### ### #            UTILS                 # ### #####
#                                                      #
########################################################


@views function get_overlap(k,kpb,ψ,pw_basis; K_shift = [0,0,0])
    
    ###################### DOC
    #
    # Computes the overlap between u_{nk} and u{m(k+b)}
    # K_shift is the "shifting" vector correction due to the periodicity conditions imposed  on k -> ψ_k
    #
    # Remember that : u_{n(k + K_shift)}(r) = e^{-i*<K_shift,r>} u_{nk}
    #
    ##################### END_DOC
    
    Mkb = zeros(Float64,n_bands*n_bands,2) # M^{k,b}_{(mn)} for k and b = k-kpb
    accu = 0

    # progress = Progress(n_bands*n_bands,desc = "Computing Mmn overlaps : ")

    for n in 1:n_bands
        for m in 1:n_bands
            
            ovlp = 0im
            
            #Extract Fourier coeffs and corresponding vectors in reciprocal lattice
            Gk_coeffs = ψ[k][:,m] 
            Gk_vec = G_vectors(pw_basis.kpoints[k])
            Gkpb_coeffs = ψ[kpb][:,n]
            Gkpb_vec = [ G - K_shift for G in G_vectors(pw_basis.kpoints[kpb]) ] # Don't forget the shift, see DOC of the function
            
            #Compute the map of corresponding Fourier modes
            map_fourier_modes = []
            for G1 in Gk_vec
                for G2 in Gkpb_vec
                    if  G1 == G2
                        iG1 = only(findall(x-> x==G1,Gk_vec)) #Renvoie une erreur si plus d'un élément
                        iG2 = only(findall(x-> x==G2,Gkpb_vec))
                        push!(map_fourier_modes,[iG1,iG2])
                    end
                end
            end
            
            #Compute the overlap for mn
            for (i,j) in map_fourier_modes
                ovlp += conj(Gk_coeffs[i])*Gkpb_coeffs[j]
            end
            
            accu += 1
            Mkb[accu,:] = [real(ovlp),imag(ovlp)]

            # next!(progress)
        end
    end

    Mkb

 end


function read_nnkp_file(prefix,ψ)
    
    n_bands = size(ψ[1])[2]
    
    file = open("$prefix.nnkp")
    @info "Reading nnkp file", file
    ln = [string(l) for l in eachline(file)]
    close(file)
    
    #Extract the nnkpts block
    i_nn_kpts = findall(x-> endswith(x,"nnkpts"),ln) #Indices of the first and last line of the nnkpts block
    @assert size(i_nn_kpts)[1] == 2
    char_to_vec(line) = [parse.(Int,x) for x in split(line,' ',keepempty=false)]
    nn_kpts =  [ char_to_vec(l) for l in ln[i_nn_kpts[1]+2:i_nn_kpts[2]-1] ]       #The block itself
    
    nn_kpts
    
end





########################################################
#                                                      #
##### ### #          MAIN FUNCTION           # ### #####
#                                                      #
########################################################


@views function generate_mmn_file(prefix,ψ,pw_basis)
    #Parameters
    n_bands = size(ψ[1])[2]
    k_size = only(size(ψ))
    
    #FIRST READ THE NNKP FILE
    # Generate the Mmn file from the nnkp file provided by wannier90 preprocessing.
    nn_kpts = read_nnkp_file(prefix,ψ)
    progress = Progress(only(size(nn_kpts)),desc = "Computing Mmn overlaps : ")
    #Small function for the sake of clarity
    read_nn_kpts(n) = nn_kpts[n][1],nn_kpts[n][2],nn_kpts[n][3:end]

    #Write file
    open("$prefix.mmn","w") do f
        write(f,"Generated by DFTK at ",string(now()),"\n")
        write(f,string(n_bands)*"   "*string(k_size)*"   "*string(n_bands)*"\n") #TODO num_wan
        
        for i_nnkp in 1:only(size(nn_kpts)) #Loop over all (k_points, neirest_neighbour, shif_vector)
            #Label of the matrix
            k,nnk,shift = read_nn_kpts(i_nnkp)
            write(f,string(k)*"  "*string(nnk)*"  "*string(shift[1])*"  "*string(shift[2])*"  "*string(shift[3])*"\n")   
            #Overlaps
            Mkb = get_overlap(k,nnk,ψ,pw_basis; K_shift = shift)
            for i in 1:n_bands*n_bands
                write(f, string(M[i,1])*" "*string(M[i,2])*"\n")
            end
            next!(progress)
        end
    end

end





########################################################
#                                                      #
##### ### #            BACKUP SCF            # ### #####
#                                                      #
########################################################


# a = 10.26

# # Note that vectors are stored in rows
# lattice = a / 2*[[-1.  0. -1.];
#                  [ 0   1.  1.];
#                  [ 1   1.  0.]]

# Si = ElementPsp(:Si, psp=load_psp("hgh/pbe/Si-q4"))

# atoms = [ Si => [zeros(3), 0.25*[-1,3,-1]] ]

# model = model_PBE(lattice,atoms)
# kgrid = [4,4,4] #Ligne "mp_grid"
# Ecut = 20.0
# basis = PlaneWaveBasis(model, Ecut; optimize_fft_size = true, kgrid=kgrid, use_symmetry=false)

# scfres = self_consistent_field(basis, tol=1e-12, n_bands = 4, n_ep_extra = 0 );
